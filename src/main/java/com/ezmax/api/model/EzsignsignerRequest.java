/*
 * eZmax API Definition (Full)
 * This API expose all the functionnalities for the eZmax and eZsign applications.
 *
 * The version of the OpenAPI document: 1.2.1
 * Contact: support-api@ezmax.ca
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ezmax.api.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import eZmaxAPI.JSON;

/**
 * An Ezsignsigner Object
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-01-20T18:49:43.941195549Z[Etc/UTC]", comments = "Generator version: 7.10.0")
public class EzsignsignerRequest {
  public static final String SERIALIZED_NAME_FKI_USERLOGINTYPE_I_D = "fkiUserlogintypeID";
  @SerializedName(SERIALIZED_NAME_FKI_USERLOGINTYPE_I_D)
  @javax.annotation.Nullable
  private Integer fkiUserlogintypeID;

  public static final String SERIALIZED_NAME_FKI_TAXASSIGNMENT_I_D = "fkiTaxassignmentID";
  @SerializedName(SERIALIZED_NAME_FKI_TAXASSIGNMENT_I_D)
  @javax.annotation.Nonnull
  private Integer fkiTaxassignmentID;

  public static final String SERIALIZED_NAME_FKI_SECRETQUESTION_I_D = "fkiSecretquestionID";
  @SerializedName(SERIALIZED_NAME_FKI_SECRETQUESTION_I_D)
  @javax.annotation.Nullable
  private Integer fkiSecretquestionID;

  /**
   * The method the Ezsignsigner will authenticate to the signing platform.  1. **Password** means the Ezsignsigner will receive a secure link by email. 2. **PasswordPhone** means the Ezsignsigner will receive a secure link by email and will need to authenticate using SMS or Phone call. **Additional fee applies**. 3. **PasswordQuestion** means the Ezsignsigner will receive a secure link by email and will need to authenticate using a predefined question and answer. 4. **InPersonPhone** means the Ezsignsigner will only be able to sign \&quot;In-Person\&quot; and will need to authenticate using SMS or Phone call. No email will be sent for invitation to sign. **Additional fee applies**. 5. **InPerson** means the Ezsignsigner will only be able to sign \&quot;In-Person\&quot; and there won&#39;t be any authentication. No email will be sent for invitation to sign. Make sure you evaluate the risk of signature denial and at minimum, we recommend you use a handwritten signature type.
   */
  @JsonAdapter(EEzsignsignerLogintypeEnum.Adapter.class)
  public enum EEzsignsignerLogintypeEnum {
    PASSWORD("Password"),
    
    PASSWORD_PHONE("PasswordPhone"),
    
    PASSWORD_QUESTION("PasswordQuestion"),
    
    IN_PERSON_PHONE("InPersonPhone"),
    
    IN_PERSON("InPerson");

    private String value;

    EEzsignsignerLogintypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static EEzsignsignerLogintypeEnum fromValue(String value) {
      for (EEzsignsignerLogintypeEnum b : EEzsignsignerLogintypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<EEzsignsignerLogintypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final EEzsignsignerLogintypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public EEzsignsignerLogintypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return EEzsignsignerLogintypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      EEzsignsignerLogintypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_E_EZSIGNSIGNER_LOGINTYPE = "eEzsignsignerLogintype";
  @Deprecated
  @SerializedName(SERIALIZED_NAME_E_EZSIGNSIGNER_LOGINTYPE)
  @javax.annotation.Nullable
  private EEzsignsignerLogintypeEnum eEzsignsignerLogintype;

  public static final String SERIALIZED_NAME_S_EZSIGNSIGNER_SECRETANSWER = "sEzsignsignerSecretanswer";
  @SerializedName(SERIALIZED_NAME_S_EZSIGNSIGNER_SECRETANSWER)
  @javax.annotation.Nullable
  private String sEzsignsignerSecretanswer;

  public EzsignsignerRequest() {
  }

  public EzsignsignerRequest fkiUserlogintypeID(@javax.annotation.Nullable Integer fkiUserlogintypeID) {
    this.fkiUserlogintypeID = fkiUserlogintypeID;
    return this;
  }

  /**
   * The unique ID of the Userlogintype  Valid values:  |Value|Description|Detail| |-|-|-| |1|**Email Only**|The Ezsignsigner will receive a secure link by email| |2|**Email and phone or SMS**|The Ezsignsigner will receive a secure link by email and will need to authenticate using SMS or Phone call. **Additional fee applies**| |3|**Email and secret question**|The Ezsignsigner will receive a secure link by email and will need to authenticate using a predefined question and answer| |4|**In person only**|The Ezsignsigner will only be able to sign \&quot;In-Person\&quot; and there won&#39;t be any authentication. No email will be sent for invitation to sign. Make sure you evaluate the risk of signature denial and at minimum, we recommend you use a handwritten signature type| |5|**In person with phone or SMS**|The Ezsignsigner will only be able to sign \&quot;In-Person\&quot; and will need to authenticate using SMS or Phone call. No email will be sent for invitation to sign. **Additional fee applies**| |6|**Embedded**|The Ezsignsigner will only be able to sign in the embedded solution. No email will be sent for invitation to sign. **Additional fee applies**|   |7|**Embedded with phone or SMS**|The Ezsignsigner will only be able to sign in the embedded solution and will need to authenticate using SMS or Phone call. No email will be sent for invitation to sign. **Additional fee applies**|   |8|**No validation**|The Ezsignsigner will not receive an email and won&#39;t have to validate his connection using 2 factor. **Additional fee applies**|      |9|**Sms only**|The Ezsignsigner will not receive an email but will will need to authenticate using SMS. **Additional fee applies**|     
   * minimum: 0
   * @return fkiUserlogintypeID
   */
  @javax.annotation.Nullable
  public Integer getFkiUserlogintypeID() {
    return fkiUserlogintypeID;
  }

  public void setFkiUserlogintypeID(@javax.annotation.Nullable Integer fkiUserlogintypeID) {
    this.fkiUserlogintypeID = fkiUserlogintypeID;
  }


  public EzsignsignerRequest fkiTaxassignmentID(@javax.annotation.Nonnull Integer fkiTaxassignmentID) {
    this.fkiTaxassignmentID = fkiTaxassignmentID;
    return this;
  }

  /**
   * The unique ID of the Taxassignment.  Valid values:  |Value|Description| |-|-| |1|No tax| |2|GST| |3|HST (ON)| |4|HST (NB)| |5|HST (NS)| |6|HST (NL)| |7|HST (PE)| |8|GST + QST (QC)| |9|GST + QST (QC) Non-Recoverable| |10|GST + PST (BC)| |11|GST + PST (SK)| |12|GST + RST (MB)| |13|GST + PST (BC) Non-Recoverable| |14|GST + PST (SK) Non-Recoverable| |15|GST + RST (MB) Non-Recoverable|
   * minimum: 0
   * maximum: 15
   * @return fkiTaxassignmentID
   */
  @javax.annotation.Nonnull
  public Integer getFkiTaxassignmentID() {
    return fkiTaxassignmentID;
  }

  public void setFkiTaxassignmentID(@javax.annotation.Nonnull Integer fkiTaxassignmentID) {
    this.fkiTaxassignmentID = fkiTaxassignmentID;
  }


  public EzsignsignerRequest fkiSecretquestionID(@javax.annotation.Nullable Integer fkiSecretquestionID) {
    this.fkiSecretquestionID = fkiSecretquestionID;
    return this;
  }

  /**
   * The unique ID of the Secretquestion.  Valid values:  |Value|Description| |-|-| |1|The name of the hospital in which you were born| |2|The name of your grade school| |3|The last name of your favorite teacher| |4|Your favorite sports team| |5|Your favorite TV show| |6|Your favorite movie| |7|The name of the street on which you grew up| |8|The name of your first employer| |9|Your first car| |10|Your favorite food| |11|The name of your first pet| |12|Favorite musician/band| |13|What instrument you play| |14|Your father&#39;s middle name| |15|Your mother&#39;s maiden name| |16|Name of your eldest child| |17|Your spouse&#39;s middle name| |18|Favorite restaurant| |19|Childhood nickname| |20|Favorite vacation destination| |21|Your boat&#39;s name| |22|Date of Birth (YYYY-MM-DD)| |22|Secret Code| |22|Your reference code|
   * minimum: 0
   * @return fkiSecretquestionID
   */
  @javax.annotation.Nullable
  public Integer getFkiSecretquestionID() {
    return fkiSecretquestionID;
  }

  public void setFkiSecretquestionID(@javax.annotation.Nullable Integer fkiSecretquestionID) {
    this.fkiSecretquestionID = fkiSecretquestionID;
  }


  @Deprecated
  public EzsignsignerRequest eEzsignsignerLogintype(@javax.annotation.Nullable EEzsignsignerLogintypeEnum eEzsignsignerLogintype) {
    this.eEzsignsignerLogintype = eEzsignsignerLogintype;
    return this;
  }

  /**
   * The method the Ezsignsigner will authenticate to the signing platform.  1. **Password** means the Ezsignsigner will receive a secure link by email. 2. **PasswordPhone** means the Ezsignsigner will receive a secure link by email and will need to authenticate using SMS or Phone call. **Additional fee applies**. 3. **PasswordQuestion** means the Ezsignsigner will receive a secure link by email and will need to authenticate using a predefined question and answer. 4. **InPersonPhone** means the Ezsignsigner will only be able to sign \&quot;In-Person\&quot; and will need to authenticate using SMS or Phone call. No email will be sent for invitation to sign. **Additional fee applies**. 5. **InPerson** means the Ezsignsigner will only be able to sign \&quot;In-Person\&quot; and there won&#39;t be any authentication. No email will be sent for invitation to sign. Make sure you evaluate the risk of signature denial and at minimum, we recommend you use a handwritten signature type.
   * @return eEzsignsignerLogintype
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public EEzsignsignerLogintypeEnum geteEzsignsignerLogintype() {
    return eEzsignsignerLogintype;
  }

  @Deprecated
  public void seteEzsignsignerLogintype(@javax.annotation.Nullable EEzsignsignerLogintypeEnum eEzsignsignerLogintype) {
    this.eEzsignsignerLogintype = eEzsignsignerLogintype;
  }


  public EzsignsignerRequest sEzsignsignerSecretanswer(@javax.annotation.Nullable String sEzsignsignerSecretanswer) {
    this.sEzsignsignerSecretanswer = sEzsignsignerSecretanswer;
    return this;
  }

  /**
   * The predefined answer to the secret question the Ezsignsigner will need to provide to successfully authenticate.
   * @return sEzsignsignerSecretanswer
   */
  @javax.annotation.Nullable
  public String getsEzsignsignerSecretanswer() {
    return sEzsignsignerSecretanswer;
  }

  public void setsEzsignsignerSecretanswer(@javax.annotation.Nullable String sEzsignsignerSecretanswer) {
    this.sEzsignsignerSecretanswer = sEzsignsignerSecretanswer;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EzsignsignerRequest ezsignsignerRequest = (EzsignsignerRequest) o;
    return Objects.equals(this.fkiUserlogintypeID, ezsignsignerRequest.fkiUserlogintypeID) &&
        Objects.equals(this.fkiTaxassignmentID, ezsignsignerRequest.fkiTaxassignmentID) &&
        Objects.equals(this.fkiSecretquestionID, ezsignsignerRequest.fkiSecretquestionID) &&
        Objects.equals(this.eEzsignsignerLogintype, ezsignsignerRequest.eEzsignsignerLogintype) &&
        Objects.equals(this.sEzsignsignerSecretanswer, ezsignsignerRequest.sEzsignsignerSecretanswer);
  }

  @Override
  public int hashCode() {
    return Objects.hash(fkiUserlogintypeID, fkiTaxassignmentID, fkiSecretquestionID, eEzsignsignerLogintype, sEzsignsignerSecretanswer);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EzsignsignerRequest {\n");
    sb.append("    fkiUserlogintypeID: ").append(toIndentedString(fkiUserlogintypeID)).append("\n");
    sb.append("    fkiTaxassignmentID: ").append(toIndentedString(fkiTaxassignmentID)).append("\n");
    sb.append("    fkiSecretquestionID: ").append(toIndentedString(fkiSecretquestionID)).append("\n");
    sb.append("    eEzsignsignerLogintype: ").append(toIndentedString(eEzsignsignerLogintype)).append("\n");
    sb.append("    sEzsignsignerSecretanswer: ").append(toIndentedString(sEzsignsignerSecretanswer)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("fkiUserlogintypeID");
    openapiFields.add("fkiTaxassignmentID");
    openapiFields.add("fkiSecretquestionID");
    openapiFields.add("eEzsignsignerLogintype");
    openapiFields.add("sEzsignsignerSecretanswer");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("fkiTaxassignmentID");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to EzsignsignerRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!EzsignsignerRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in EzsignsignerRequest is not found in the empty JSON string", EzsignsignerRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!EzsignsignerRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `EzsignsignerRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : EzsignsignerRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("eEzsignsignerLogintype") != null && !jsonObj.get("eEzsignsignerLogintype").isJsonNull()) && !jsonObj.get("eEzsignsignerLogintype").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `eEzsignsignerLogintype` to be a primitive type in the JSON string but got `%s`", jsonObj.get("eEzsignsignerLogintype").toString()));
      }
      // validate the optional field `eEzsignsignerLogintype`
      if (jsonObj.get("eEzsignsignerLogintype") != null && !jsonObj.get("eEzsignsignerLogintype").isJsonNull()) {
        EEzsignsignerLogintypeEnum.validateJsonElement(jsonObj.get("eEzsignsignerLogintype"));
      }
      if ((jsonObj.get("sEzsignsignerSecretanswer") != null && !jsonObj.get("sEzsignsignerSecretanswer").isJsonNull()) && !jsonObj.get("sEzsignsignerSecretanswer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sEzsignsignerSecretanswer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sEzsignsignerSecretanswer").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!EzsignsignerRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'EzsignsignerRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<EzsignsignerRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(EzsignsignerRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<EzsignsignerRequest>() {
           @Override
           public void write(JsonWriter out, EzsignsignerRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public EzsignsignerRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of EzsignsignerRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of EzsignsignerRequest
   * @throws IOException if the JSON string is invalid with respect to EzsignsignerRequest
   */
  public static EzsignsignerRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, EzsignsignerRequest.class);
  }

  /**
   * Convert an instance of EzsignsignerRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

